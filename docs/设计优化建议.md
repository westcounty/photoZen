---
  PhotoZen 视觉体验与动效设计优化方案

  总体评估

  当前设计优势
  ┌────────────┬────────┬────────────────────────────────────────────────┐
  │    维度    │  评分  │                      说明                      │
  ├────────────┼────────┼────────────────────────────────────────────────┤
  │ 色彩系统   │ 8/10   │ 语义化配色清晰(绿/红/黄)，深色主题适合照片浏览 │
  ├────────────┼────────┼────────────────────────────────────────────────┤
  │ 间距系统   │ 7/10   │ 基本遵循4dp网格，但缺乏统一的Token管理         │
  ├────────────┼────────┼────────────────────────────────────────────────┤
  │ 动效系统   │ 7.5/10 │ Spring动画使用得当，但缺乏系统性规范           │
  ├────────────┼────────┼────────────────────────────────────────────────┤
  │ 组件一致性 │ 7/10   │ 部分组件风格不统一，圆角/阴影规则分散          │
  ├────────────┼────────┼────────────────────────────────────────────────┤
  │ 微交互     │ 6.5/10 │ 触觉反馈完善，但视觉反馈层次可增强             │
  └────────────┴────────┴────────────────────────────────────────────────┘
  核心问题识别

  ┌─────────────────────────────────────────────────────────────────┐
  │ 1. 缺乏统一设计Token系统 - 圆角/阴影/间距值分散在各组件中           │
  │ 2. 动效规范不系统 - 时长/缓动曲线缺乏统一定义                      │
  │ 3. 层次感不足 - Surface层级扁平，缺乏空间深度                      │
  │ 4. 微交互反馈单一 - 主要依赖触觉，视觉反馈可更丰富                  │
  │ 5. 过渡动画缺失 - 页面/组件切换缺乏连贯的过渡体验                   │
  └─────────────────────────────────────────────────────────────────┘

  ---
  一、设计系统优化方案

  1.1 建立统一Design Token系统

  新建文件: ui/theme/DesignTokens.kt

  /**
   * PhotoZen Design System Tokens
   * 统一管理所有设计规范值
   */
  object PicZenTokens {

      // ═══════════════════════════════════════════════════════════
      // 圆角系统 - 基于视觉层级的渐进式圆角
      // ═══════════════════════════════════════════════════════════
      object Radius {
          val None = 0.dp
          val XS = 4.dp      // 极小元素: 进度条、徽章内角
          val S = 8.dp       // 小型元素: Chip、标签
          val M = 12.dp      // 中型元素: 按钮、输入框
          val L = 16.dp      // 大型元素: 卡片、对话框
          val XL = 24.dp     // 超大元素: 底部Sheet、主卡片
          val Full = 9999.dp // 圆形: 头像、圆形按钮
      }

      // ═══════════════════════════════════════════════════════════
      // 间距系统 - 8dp基准的Harmonic Scale
      // ═══════════════════════════════════════════════════════════
      object Spacing {
          val XXS = 2.dp     // 微间距: 图标与文字紧贴
          val XS = 4.dp      // 极小间距: 行内元素
          val S = 8.dp       // 小间距: 相关元素组
          val M = 12.dp      // 中间距: 按钮组、列表项
          val L = 16.dp      // 大间距: 区块分隔
          val XL = 24.dp     // 超大间距: 卡片内边距
          val XXL = 32.dp    // 特大间距: 页面边距
          val XXXL = 48.dp   // 巨型间距: 空状态插图
      }

      // ═══════════════════════════════════════════════════════════
      // 阴影/高度系统 - 层级递进
      // ═══════════════════════════════════════════════════════════
      object Elevation {
          val Level0 = 0.dp   // 平面: 背景内容
          val Level1 = 1.dp   // 微浮: 卡片默认态
          val Level2 = 3.dp   // 轻浮: 卡片悬停态
          val Level3 = 6.dp   // 中浮: 下拉菜单、Chip
          val Level4 = 8.dp   // 高浮: 底部栏、悬浮按钮
          val Level5 = 12.dp  // 顶层: 对话框、全屏覆盖
      }

      // ═══════════════════════════════════════════════════════════
      // 图标尺寸系统
      // ═══════════════════════════════════════════════════════════
      object IconSize {
          val XS = 14.dp     // 极小: 徽章内图标
          val S = 18.dp      // 小型: Chip内图标、紧凑按钮
          val M = 20.dp      // 中型: 底部栏图标
          val L = 24.dp      // 标准: 列表项、顶栏图标
          val XL = 32.dp     // 大型: 状态指示
          val XXL = 48.dp    // 超大: 空状态、快捷操作
          val XXXL = 56.dp   // 巨型: 空状态主图标
      }

      // ═══════════════════════════════════════════════════════════
      // 透明度系统 - 语义化命名
      // ═══════════════════════════════════════════════════════════
      object Alpha {
          const val Disabled = 0.38f      // 禁用态
          const val Medium = 0.60f        // 中等强调
          const val High = 0.87f          // 高强调
          const val Hover = 0.08f         // 悬停叠加
          const val Focus = 0.12f         // 焦点叠加
          const val Pressed = 0.16f       // 按下叠加
          const val Scrim = 0.32f         // 遮罩层
          const val Overlay = 0.80f       // 覆盖层背景
          const val SurfaceTint = 0.05f   // 表面着色
          const val ContainerTint = 0.12f // 容器着色
      }
  }

  1.2 动效Token系统

  新建文件: ui/theme/MotionTokens.kt

  /**
   * PhotoZen Motion System
   * 统一管理所有动画规范
   */
  object PicZenMotion {

      // ═══════════════════════════════════════════════════════════
      // 时长系统 - 基于交互类型
      // ═══════════════════════════════════════════════════════════
      object Duration {
          const val Instant = 50          // 即时反馈: 按钮状态
          const val Quick = 100           // 快速: 开关切换
          const val Fast = 150            // 较快: 淡入淡出
          const val Normal = 200          // 标准: 尺寸变化
          const val Moderate = 300        // 中等: 页面过渡
          const val Slow = 400            // 较慢: 复杂动画
          const val Emphasis = 500        // 强调: 庆祝动效
      }

      // ═══════════════════════════════════════════════════════════
      // 缓动曲线 - Material 3 标准
      // ═══════════════════════════════════════════════════════════
      object Easing {
          // 标准曲线 - 大多数过渡
          val Standard = CubicBezierEasing(0.2f, 0f, 0f, 1f)
          val StandardDecelerate = CubicBezierEasing(0f, 0f, 0f, 1f)
          val StandardAccelerate = CubicBezierEasing(0.3f, 0f, 1f, 1f)

          // 强调曲线 - 引入注意
          val Emphasized = CubicBezierEasing(0.2f, 0f, 0f, 1f)
          val EmphasizedDecelerate = CubicBezierEasing(0.05f, 0.7f, 0.1f, 1f)
          val EmphasizedAccelerate = CubicBezierEasing(0.3f, 0f, 0.8f, 0.15f)

          // 弹性曲线 - 自定义
          val Bounce = CubicBezierEasing(0.34f, 1.56f, 0.64f, 1f)
      }

      // ═══════════════════════════════════════════════════════════
      // Spring配置 - 统一弹性动画参数
      // ═══════════════════════════════════════════════════════════
      object Springs {
          // 快速响应 - 按钮、开关
          val Snappy = spring<Float>(
              dampingRatio = Spring.DampingRatioNoBouncy,
              stiffness = Spring.StiffnessHigh
          )

          // 标准弹性 - 卡片、列表项
          val Default = spring<Float>(
              dampingRatio = Spring.DampingRatioLowBouncy,
              stiffness = Spring.StiffnessMedium
          )

          // 灵动弹性 - 滑动卡片、手势回弹
          val Playful = spring<Float>(
              dampingRatio = Spring.DampingRatioMediumBouncy,
              stiffness = Spring.StiffnessMedium
          )

          // 柔和弹性 - 页面过渡
          val Gentle = spring<Float>(
              dampingRatio = Spring.DampingRatioLowBouncy,
              stiffness = Spring.StiffnessLow
          )
      }

      // ═══════════════════════════════════════════════════════════
      // 预设动画Spec
      // ═══════════════════════════════════════════════════════════
      object Specs {
          val fadeIn = fadeIn(tween(Duration.Fast, easing = Easing.StandardDecelerate))
          val fadeOut = fadeOut(tween(Duration.Quick, easing = Easing.StandardAccelerate))

          val scaleIn = scaleIn(
              initialScale = 0.92f,
              animationSpec = tween(Duration.Normal, easing = Easing.EmphasizedDecelerate)
          )
          val scaleOut = scaleOut(
              targetScale = 0.92f,
              animationSpec = tween(Duration.Quick, easing = Easing.StandardAccelerate)
          )

          val slideInFromBottom = slideInVertically(
              initialOffsetY = { it / 4 },
              animationSpec = tween(Duration.Moderate, easing = Easing.EmphasizedDecelerate)
          )
          val slideOutToBottom = slideOutVertically(
              targetOffsetY = { it / 4 },
              animationSpec = tween(Duration.Fast, easing = Easing.StandardAccelerate)
          )
      }
  }

  ---
  二、色彩系统优化

  2.1 增强表面层级感

  问题: 当前深色主题背景层次扁平 (#0F0F0F → #171717 → #252525 差异过小)

  优化方案:

  // 优化后的深色主题表面色彩系统
  object PicZenDarkSurfaces {
      // 基础背景 - 纯黑偏冷
      val Background = Color(0xFF0A0A0C)     // 更深，带微蓝

      // Surface层级 - 递进式提亮
      val Surface0 = Color(0xFF0F0F12)       // Level 0: 卡片底层
      val Surface1 = Color(0xFF1A1A1F)       // Level 1: 默认卡片
      val Surface2 = Color(0xFF232329)       // Level 2: 悬浮卡片
      val Surface3 = Color(0xFF2C2C35)       // Level 3: 下拉菜单
      val Surface4 = Color(0xFF35353F)       // Level 4: 底部栏
      val Surface5 = Color(0xFF3E3E4A)       // Level 5: 对话框

      // 容器色 - 带品牌色微调
      val PrimaryContainer = Color(0xFF004D47)    // 青绿容器
      val SecondaryContainer = Color(0xFF2A3635)  // 中性容器
      val TertiaryContainer = Color(0xFF4A3A1A)   // 琥珀容器
  }

  2.2 优化操作反馈色彩

  增加渐变和光晕效果:

  object PicZenActionColors {
      // Keep - 绿色系
      object Keep {
          val Primary = Color(0xFF22C55E)        // 主色
          val Light = Color(0xFF4ADE80)          // 高亮
          val Dark = Color(0xFF16A34A)           // 深色
          val Glow = Color(0x4022C55E)           // 光晕 (25% alpha)
          val Container = Color(0xFF0D3320)      // 容器背景
          val Gradient = Brush.linearGradient(   // 渐变
              colors = listOf(Primary, Light)
          )
      }

      // Trash - 红色系
      object Trash {
          val Primary = Color(0xFFEF4444)
          val Light = Color(0xFFF87171)
          val Dark = Color(0xFFDC2626)
          val Glow = Color(0x40EF4444)
          val Container = Color(0xFF3D1515)
          val Gradient = Brush.linearGradient(
              colors = listOf(Primary, Light)
          )
      }

      // Maybe - 琥珀系
      object Maybe {
          val Primary = Color(0xFFFBBF24)
          val Light = Color(0xFFFCD34D)
          val Dark = Color(0xFFF59E0B)
          val Glow = Color(0x40FBBF24)
          val Container = Color(0xFF3D3010)
          val Gradient = Brush.linearGradient(
              colors = listOf(Primary, Light)
          )
      }
  }

  ---
  三、组件视觉优化详案

  3.1 卡片组件增强

  当前问题: 卡片缺乏层次感和视觉焦点

  优化方案:

  /**
   * 增强型卡片组件
   * - 微妙渐变背景
   * - 精细边框
   * - 悬停/按压状态反馈
   */
  @Composable
  fun EnhancedCard(
      onClick: () -> Unit,
      modifier: Modifier = Modifier,
      elevation: Dp = PicZenTokens.Elevation.Level1,
      content: @Composable ColumnScope.() -> Unit
  ) {
      val interactionSource = remember { MutableInteractionSource() }
      val isPressed by interactionSource.collectIsPressedAsState()

      // 动态缩放
      val scale by animateFloatAsState(
          targetValue = if (isPressed) 0.98f else 1f,
          animationSpec = PicZenMotion.Springs.Snappy
      )

      // 动态高度
      val animatedElevation by animateDpAsState(
          targetValue = if (isPressed) elevation - 2.dp else elevation,
          animationSpec = tween(PicZenMotion.Duration.Quick)
      )

      Surface(
          onClick = onClick,
          modifier = modifier
              .graphicsLayer {
                  scaleX = scale
                  scaleY = scale
              },
          shape = RoundedCornerShape(PicZenTokens.Radius.L),
          color = MaterialTheme.colorScheme.surfaceVariant,
          tonalElevation = animatedElevation,
          shadowElevation = animatedElevation,
          border = BorderStroke(
              width = 0.5.dp,
              color = MaterialTheme.colorScheme.outlineVariant.copy(
                  alpha = PicZenTokens.Alpha.Medium
              )
          ),
          interactionSource = interactionSource
      ) {
          // 顶部微渐变叠加
          Box {
              Column(content = content)

              // 微妙的顶部光泽
              Box(
                  modifier = Modifier
                      .fillMaxWidth()
                      .height(80.dp)
                      .background(
                          Brush.verticalGradient(
                              colors = listOf(
                                  Color.White.copy(alpha = 0.03f),
                                  Color.Transparent
                              )
                          )
                      )
              )
          }
      }
  }

  3.2 底部操作栏重设计

  当前问题: 视觉较重，缺乏层次

  优化方案:

  /**
   * 毛玻璃效果底部操作栏
   * - 模糊背景
   * - 浮动圆角设计
   * - 微动效反馈
   */
  @Composable
  fun FloatingBottomBar(
      actions: List<BottomBarAction>,
      modifier: Modifier = Modifier
  ) {
      Box(
          modifier = modifier
              .fillMaxWidth()
              .padding(horizontal = PicZenTokens.Spacing.L)
              .padding(bottom = PicZenTokens.Spacing.M)
      ) {
          Surface(
              modifier = Modifier
                  .fillMaxWidth()
                  .height(72.dp),
              shape = RoundedCornerShape(PicZenTokens.Radius.XL),
              color = MaterialTheme.colorScheme.surface.copy(alpha = 0.85f),
              tonalElevation = PicZenTokens.Elevation.Level4,
              shadowElevation = PicZenTokens.Elevation.Level3,
              border = BorderStroke(
                  0.5.dp,
                  MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.3f)
              )
          ) {
              Row(
                  modifier = Modifier
                      .fillMaxSize()
                      .padding(horizontal = PicZenTokens.Spacing.M),
                  horizontalArrangement = Arrangement.SpaceEvenly,
                  verticalAlignment = Alignment.CenterVertically
              ) {
                  actions.forEach { action ->
                      FloatingActionItem(action = action)
                  }
              }
          }
      }
  }

  @Composable
  private fun FloatingActionItem(
      action: BottomBarAction
  ) {
      val interactionSource = remember { MutableInteractionSource() }
      val isPressed by interactionSource.collectIsPressedAsState()

      val scale by animateFloatAsState(
          targetValue = if (isPressed) 0.9f else 1f,
          animationSpec = PicZenMotion.Springs.Snappy
      )

      val iconOffset by animateDpAsState(
          targetValue = if (isPressed) 2.dp else 0.dp,
          animationSpec = PicZenMotion.Springs.Snappy
      )

      Column(
          modifier = Modifier
              .graphicsLayer {
                  scaleX = scale
                  scaleY = scale
              }
              .clickable(
                  interactionSource = interactionSource,
                  indication = null,
                  onClick = action.onClick
              )
              .padding(horizontal = PicZenTokens.Spacing.S),
          horizontalAlignment = Alignment.CenterHorizontally
      ) {
          // 图标容器 - 带动态背景
          Box(
              modifier = Modifier
                  .size(44.dp)
                  .offset(y = iconOffset)
                  .background(
                      color = action.tintColor.copy(alpha =
                          if (isPressed) PicZenTokens.Alpha.Pressed
                          else PicZenTokens.Alpha.Hover
                      ),
                      shape = CircleShape
                  ),
              contentAlignment = Alignment.Center
          ) {
              Icon(
                  imageVector = action.icon,
                  contentDescription = action.label,
                  modifier = Modifier.size(PicZenTokens.IconSize.M),
                  tint = action.tintColor
              )
          }

          Spacer(modifier = Modifier.height(PicZenTokens.Spacing.XS))

          Text(
              text = action.label,
              style = MaterialTheme.typography.labelSmall,
              color = MaterialTheme.colorScheme.onSurfaceVariant
          )
      }
  }

  3.3 照片状态徽章优化

  当前问题: 三角形徽章视觉粗糙，辨识度可提升

  优化方案:

  /**
   * 精致圆角状态徽章
   * - 带光泽效果
   * - 微阴影层次
   * - 平滑圆角
   */
  @Composable
  fun PhotoStatusPill(
      status: PhotoStatus,
      modifier: Modifier = Modifier,
      size: PillSize = PillSize.Medium
  ) {
      val (icon, color) = when (status) {
          PhotoStatus.KEEP -> Icons.Rounded.Check to PicZenActionColors.Keep.Primary
          PhotoStatus.MAYBE -> Icons.Rounded.Schedule to PicZenActionColors.Maybe.Primary
          PhotoStatus.TRASH -> Icons.Rounded.Close to PicZenActionColors.Trash.Primary
          else -> return // UNSORTED 不显示
      }

      val dimensions = when (size) {
          PillSize.Small -> 18.dp to 10.dp
          PillSize.Medium -> 24.dp to 14.dp
          PillSize.Large -> 32.dp to 18.dp
      }

      Box(
          modifier = modifier
              .size(dimensions.first)
              .shadow(
                  elevation = 2.dp,
                  shape = RoundedCornerShape(PicZenTokens.Radius.S),
                  ambientColor = color.copy(alpha = 0.3f),
                  spotColor = color.copy(alpha = 0.2f)
              )
              .background(
                  brush = Brush.linearGradient(
                      colors = listOf(
                          color,
                          color.copy(alpha = 0.85f)
                      ),
                      start = Offset(0f, 0f),
                      end = Offset(dimensions.first.value, dimensions.first.value)
                  ),
                  shape = RoundedCornerShape(PicZenTokens.Radius.S)
              ),
          contentAlignment = Alignment.Center
      ) {
          // 顶部光泽
          Box(
              modifier = Modifier
                  .fillMaxSize()
                  .background(
                      brush = Brush.verticalGradient(
                          colors = listOf(
                              Color.White.copy(alpha = 0.25f),
                              Color.Transparent
                          ),
                          startY = 0f,
                          endY = dimensions.first.value * 0.5f
                      ),
                      shape = RoundedCornerShape(PicZenTokens.Radius.S)
                  )
          )

          Icon(
              imageVector = icon,
              contentDescription = null,
              modifier = Modifier.size(dimensions.second),
              tint = Color.White
          )
      }
  }

  3.4 滑动卡片视觉增强

  当前问题: 滑动反馈主要依赖位移和透明度，视觉层次单一

  优化方案 - 增加动态光效:

  /**
   * 增强型滑动卡片
   * - 方向感知光晕
   * - 动态阴影
   * - 倾斜透视效果
   */
  @Composable
  fun EnhancedSwipeCard(
      photo: Photo,
      modifier: Modifier = Modifier,
      // ... 其他参数
  ) {
      val offsetX = remember { Animatable(0f) }
      val offsetY = remember { Animatable(0f) }

      // 计算滑动进度 (0-1)
      val swipeProgress = remember {
          derivedStateOf {
              val absX = abs(offsetX.value)
              val absY = abs(offsetY.value)
              (maxOf(absX, absY) / swipeThreshold).coerceIn(0f, 1f)
          }
      }

      // 动态颜色 - 根据滑动方向
      val glowColor = remember {
          derivedStateOf {
              when {
                  offsetX.value > 50 -> PicZenActionColors.Keep.Glow
                  offsetX.value < -50 -> PicZenActionColors.Trash.Glow
                  offsetY.value < -50 -> PicZenActionColors.Trash.Glow
                  offsetY.value > 50 -> PicZenActionColors.Maybe.Glow
                  else -> Color.Transparent
              }
          }
      }

      Box(
          modifier = modifier
              .graphicsLayer {
                  translationX = offsetX.value
                  translationY = offsetY.value

                  // 倾斜效果 - 基于水平偏移
                  rotationZ = (offsetX.value / screenWidth) * 12f

                  // 微透视效果 - 基于垂直偏移
                  rotationX = -(offsetY.value / screenHeight) * 5f

                  // 动态缩放 - 下滑时缩小
                  val scaleValue = 1f - (abs(offsetY.value) / screenHeight) * 0.15f
                  scaleX = scaleValue
                  scaleY = scaleValue

                  // 边缘阴影动态化
                  shadowElevation = 8.dp.value + (swipeProgress.value * 8f)
              }
      ) {
          // 照片内容
          AsyncImage(
              model = photo.uri,
              contentDescription = null,
              modifier = Modifier
                  .fillMaxSize()
                  .clip(RoundedCornerShape(PicZenTokens.Radius.L))
          )

          // 方向感知光晕层
          Box(
              modifier = Modifier
                  .fillMaxSize()
                  .background(
                      brush = Brush.radialGradient(
                          colors = listOf(
                              glowColor.value,
                              Color.Transparent
                          ),
                          center = when {
                              offsetX.value > 0 -> Offset(0f, size.height / 2)    // 右滑: 左侧发光
                              offsetX.value < 0 -> Offset(size.width, size.height / 2) // 左滑: 右侧发光
                              offsetY.value < 0 -> Offset(size.width / 2, size.height) // 上滑: 底部发光
                              else -> Offset(size.width / 2, 0f)                  // 下滑: 顶部发光
                          },
                          radius = size.width * 0.8f * swipeProgress.value
                      ),
                      shape = RoundedCornerShape(PicZenTokens.Radius.L)
                  )
          )

          // 方向指示器 (已有，保持)
          DirectionIndicator(...)
      }
  }

  ---
  四、动效系统优化详案

  4.1 页面过渡动画标准化

  当前问题: 页面切换缺乏连贯性

  优化方案:

  /**
   * 统一页面过渡规范
   */
  object PicZenTransitions {

      // 标准前进过渡 - 新页面从右滑入
      val Forward = object : AnimatedContentTransitionScope<NavBackStackEntry>.() -> ContentTransform {
          override fun invoke(scope: AnimatedContentTransitionScope<NavBackStackEntry>): ContentTransform {
              return slideIntoContainer(
                  towards = AnimatedContentTransitionScope.SlideDirection.Left,
                  animationSpec = tween(
                      durationMillis = PicZenMotion.Duration.Moderate,
                      easing = PicZenMotion.Easing.EmphasizedDecelerate
                  )
              ) + fadeIn(
                  animationSpec = tween(PicZenMotion.Duration.Fast)
              ) togetherWith slideOutOfContainer(
                  towards = AnimatedContentTransitionScope.SlideDirection.Left,
                  animationSpec = tween(
                      durationMillis = PicZenMotion.Duration.Moderate,
                      easing = PicZenMotion.Easing.EmphasizedAccelerate
                  )
              ) + fadeOut(
                  animationSpec = tween(PicZenMotion.Duration.Quick)
              )
          }
      }

      // 返回过渡 - 页面从左滑入
      val Backward = object : AnimatedContentTransitionScope<NavBackStackEntry>.() -> ContentTransform {
          // ... 反向实现
      }

      // 垂直过渡 - 用于底部Sheet、全屏预览
      val VerticalExpand = fadeIn(
          animationSpec = tween(PicZenMotion.Duration.Normal)
      ) + scaleIn(
          initialScale = 0.95f,
          animationSpec = tween(
              durationMillis = PicZenMotion.Duration.Moderate,
              easing = PicZenMotion.Easing.EmphasizedDecelerate
          )
      ) togetherWith fadeOut(
          animationSpec = tween(PicZenMotion.Duration.Quick)
      )

      // 共享元素过渡 - 照片点击进入全屏
      @Composable
      fun SharedElementTransition(
          photo: Photo,
          isFullscreen: Boolean,
          content: @Composable () -> Unit
      ) {
          val transition = updateTransition(targetState = isFullscreen, label = "photo")

          val cornerRadius by transition.animateDp(
              transitionSpec = { tween(PicZenMotion.Duration.Moderate) },
              label = "corner"
          ) { fullscreen ->
              if (fullscreen) 0.dp else PicZenTokens.Radius.M
          }

          val scale by transition.animateFloat(
              transitionSpec = { spring(PicZenMotion.Springs.Default) },
              label = "scale"
          ) { fullscreen ->
              if (fullscreen) 1f else 0.9f
          }

          Box(
              modifier = Modifier
                  .graphicsLayer {
                      scaleX = scale
                      scaleY = scale
                  }
                  .clip(RoundedCornerShape(cornerRadius))
          ) {
              content()
          }
      }
  }

  4.2 列表项入场动画

  新增文件: ui/animation/ListAnimations.kt

  /**
   * 列表项渐进入场动画
   */
  @Composable
  fun AnimatedLazyColumn(
      items: List<Any>,
      modifier: Modifier = Modifier,
      content: @Composable (index: Int, item: Any) -> Unit
  ) {
      LazyColumn(modifier = modifier) {
          itemsIndexed(items) { index, item ->
              val animatedVisibility = remember { Animatable(0f) }

              LaunchedEffect(item) {
                  delay(index * 30L) // 错开入场
                  animatedVisibility.animateTo(
                      targetValue = 1f,
                      animationSpec = tween(
                          durationMillis = PicZenMotion.Duration.Normal,
                          easing = PicZenMotion.Easing.EmphasizedDecelerate
                      )
                  )
              }

              Box(
                  modifier = Modifier
                      .graphicsLayer {
                          alpha = animatedVisibility.value
                          translationY = (1f - animatedVisibility.value) * 20f
                      }
              ) {
                  content(index, item)
              }
          }
      }
  }

  4.3 手势反馈增强

  优化滑动卡片的弹性回弹:

  /**
   * 增强型手势回弹
   * - 基于速度的弹性强度
   * - 方向感知的阻尼
   */
  suspend fun AnimatableOffset.snapBackWithBounce(
      velocity: Offset,
      onComplete: () -> Unit
  ) {
      val speed = sqrt(velocity.x.pow(2) + velocity.y.pow(2))

      // 速度越快，弹性越强
      val dampingRatio = when {
          speed > 2000f -> Spring.DampingRatioMediumBouncy
          speed > 1000f -> Spring.DampingRatioLowBouncy
          else -> Spring.DampingRatioNoBouncy
      }

      // 先过冲再回弹
      val overshoot = when {
          speed > 1500f -> -velocity.x * 0.08f to -velocity.y * 0.08f
          else -> 0f to 0f
      }

      if (overshoot.first != 0f || overshoot.second != 0f) {
          animateTo(
              Offset(overshoot.first, overshoot.second),
              animationSpec = tween(
                  durationMillis = 80,
                  easing = FastOutLinearInEasing
              )
          )
      }

      animateTo(
          Offset.Zero,
          animationSpec = spring(
              dampingRatio = dampingRatio,
              stiffness = Spring.StiffnessMedium,
              visibilityThreshold = Offset(0.1f, 0.1f)
          )
      )

      onComplete()
  }

  ---
  五、具体页面优化详案

  5.1 首页 (HomeScreen) 优化

  当前状态分析:
  - 卡片排列较密，视觉层次不够清晰
  - 快捷操作区域视觉权重不足

  优化方案:

  // 1. 增加卡片间的视觉呼吸感
  Column(
      modifier = Modifier
          .fillMaxSize()
          .padding(horizontal = PicZenTokens.Spacing.L),
      verticalArrangement = Arrangement.spacedBy(PicZenTokens.Spacing.M)
  ) {
      // 主操作卡片 - 更突出
      MainActionCard(
          modifier = Modifier.shadow(
              elevation = 12.dp,
              shape = RoundedCornerShape(PicZenTokens.Radius.XL),
              ambientColor = MaterialTheme.colorScheme.primary.copy(alpha = 0.1f)
          )
      )

      // 快捷操作 - 增加视觉权重
      QuickActionsRow(
          modifier = Modifier
              .background(
                  color = MaterialTheme.colorScheme.surfaceVariant,
                  shape = RoundedCornerShape(PicZenTokens.Radius.L)
              )
              .padding(PicZenTokens.Spacing.M)
      )
  }

  // 2. 主卡片内部布局优化
  @Composable
  fun MainActionCard(...) {
      Card(
          shape = RoundedCornerShape(PicZenTokens.Radius.XL),
          colors = CardDefaults.cardColors(
              containerColor = MaterialTheme.colorScheme.primaryContainer
          )
      ) {
          Column(
              modifier = Modifier.padding(PicZenTokens.Spacing.XL)
          ) {
              // 数字展示 - 更大、更醒目
              Text(
                  text = unsortedCount.toString(),
                  style = MaterialTheme.typography.displayLarge.copy(
                      fontWeight = FontWeight.Bold,
                      fontSize = 72.sp  // 放大数字
                  ),
                  color = MaterialTheme.colorScheme.onPrimaryContainer
              )

              // 辅助文字
              Text(
                  text = "张照片待整理",
                  style = MaterialTheme.typography.titleMedium,
                  color = MaterialTheme.colorScheme.onPrimaryContainer.copy(
                      alpha = PicZenTokens.Alpha.Medium
                  )
              )

              Spacer(modifier = Modifier.height(PicZenTokens.Spacing.L))

              // 开始按钮 - 带微动效
              StartButton(
                  text = "开始整理",
                  onClick = onStartSort
              )
          }
      }
  }

  5.2 全屏预览界面优化

  优化方案 - 增加细节层次:

  // 1. 页面指示器优化 - 胶囊式设计
  @Composable
  fun EnhancedPageIndicator(
      current: Int,
      total: Int,
      modifier: Modifier = Modifier
  ) {
      Surface(
          modifier = modifier,
          shape = RoundedCornerShape(PicZenTokens.Radius.Full),
          color = Color.Black.copy(alpha = 0.5f),
          border = BorderStroke(
              0.5.dp,
              Color.White.copy(alpha = 0.1f)
          )
      ) {
          Row(
              modifier = Modifier.padding(
                  horizontal = PicZenTokens.Spacing.M,
                  vertical = PicZenTokens.Spacing.S
              ),
              verticalAlignment = Alignment.CenterVertically
          ) {
              Text(
                  text = "${current + 1}",
                  style = MaterialTheme.typography.labelLarge,
                  fontWeight = FontWeight.Bold,
                  color = Color.White
              )
              Text(
                  text = " / $total",
                  style = MaterialTheme.typography.labelMedium,
                  color = Color.White.copy(alpha = 0.7f)
              )
          }
      }
  }

  // 2. 底部预览条优化 - 带选中放大效果
  @Composable
  fun EnhancedPreviewStrip(
      photos: List<Photo>,
      currentIndex: Int,
      onIndexChange: (Int) -> Unit
  ) {
      LazyRow(
          horizontalArrangement = Arrangement.spacedBy(PicZenTokens.Spacing.S),
          contentPadding = PaddingValues(horizontal = PicZenTokens.Spacing.L)
      ) {
          itemsIndexed(photos) { index, photo ->
              val isSelected = index == currentIndex

              val scale by animateFloatAsState(
                  targetValue = if (isSelected) 1.15f else 1f,
                  animationSpec = PicZenMotion.Springs.Default
              )

              val borderWidth by animateDpAsState(
                  targetValue = if (isSelected) 2.dp else 0.dp,
                  animationSpec = tween(PicZenMotion.Duration.Fast)
              )

              Box(
                  modifier = Modifier
                      .graphicsLayer {
                          scaleX = scale
                          scaleY = scale
                      }
                      .size(if (isSelected) 52.dp else 40.dp)
                      .clip(RoundedCornerShape(PicZenTokens.Radius.S))
                      .border(
                          width = borderWidth,
                          color = MaterialTheme.colorScheme.primary,
                          shape = RoundedCornerShape(PicZenTokens.Radius.S)
                      )
                      .clickable { onIndexChange(index) }
              ) {
                  AsyncImage(
                      model = photo.uri,
                      contentDescription = null,
                      contentScale = ContentScale.Crop,
                      modifier = Modifier.fillMaxSize()
                  )
              }
          }
      }
  }

  5.3 空状态设计优化

  优化方案 - 更生动的空状态:

  @Composable
  fun IllustratedEmptyState(
      type: EmptyStateType,
      modifier: Modifier = Modifier
  ) {
      val infiniteTransition = rememberInfiniteTransition()

      // 浮动动画
      val floatOffset by infiniteTransition.animateFloat(
          initialValue = 0f,
          targetValue = 8f,
          animationSpec = infiniteRepeatable(
              animation = tween(2000, easing = FastOutSlowInEasing),
              repeatMode = RepeatMode.Reverse
          )
      )

      Column(
          modifier = modifier
              .fillMaxWidth()
              .padding(PicZenTokens.Spacing.XXL),
          horizontalAlignment = Alignment.CenterHorizontally
      ) {
          // 动态图标容器
          Box(
              modifier = Modifier
                  .size(140.dp)
                  .offset(y = floatOffset.dp)
                  .background(
                      brush = Brush.radialGradient(
                          colors = listOf(
                              type.color.copy(alpha = 0.15f),
                              type.color.copy(alpha = 0.05f),
                              Color.Transparent
                          )
                      ),
                      shape = CircleShape
                  ),
              contentAlignment = Alignment.Center
          ) {
              // 外圈 - 虚线描边
              Canvas(modifier = Modifier.size(120.dp)) {
                  drawCircle(
                      color = type.color.copy(alpha = 0.3f),
                      radius = size.minDimension / 2,
                      style = Stroke(
                          width = 2.dp.toPx(),
                          pathEffect = PathEffect.dashPathEffect(
                              floatArrayOf(10f, 10f)
                          )
                      )
                  )
              }

              // 图标
              Icon(
                  imageVector = type.icon,
                  contentDescription = null,
                  modifier = Modifier.size(PicZenTokens.IconSize.XXXL),
                  tint = type.color
              )
          }

          Spacer(modifier = Modifier.height(PicZenTokens.Spacing.XL))

          // 标题
          Text(
              text = type.title,
              style = MaterialTheme.typography.titleLarge,
              fontWeight = FontWeight.SemiBold,
              textAlign = TextAlign.Center
          )

          Spacer(modifier = Modifier.height(PicZenTokens.Spacing.S))

          // 描述
          Text(
              text = type.description,
              style = MaterialTheme.typography.bodyMedium,
              color = MaterialTheme.colorScheme.onSurfaceVariant,
              textAlign = TextAlign.Center,
              modifier = Modifier.widthIn(max = 280.dp)
          )

          // 操作按钮
          type.action?.let { action ->
              Spacer(modifier = Modifier.height(PicZenTokens.Spacing.XL))

              FilledTonalButton(
                  onClick = action.onClick,
                  shape = RoundedCornerShape(PicZenTokens.Radius.M)
              ) {
                  Icon(
                      imageVector = action.icon,
                      contentDescription = null,
                      modifier = Modifier.size(PicZenTokens.IconSize.S)
                  )
                  Spacer(modifier = Modifier.width(PicZenTokens.Spacing.S))
                  Text(action.label)
              }
          }
      }
  }

  ---
  六、实施优先级建议

  Phase 1: 基础设施 (高优先级)
  ┌─────────────────────┬──────────┬──────────┐
  │        任务         │   文件   │ 影响范围 │
  ├─────────────────────┼──────────┼──────────┤
  │ 创建DesignTokens.kt │ 新建     │ 全局     │
  ├─────────────────────┼──────────┼──────────┤
  │ 创建MotionTokens.kt │ 新建     │ 全局     │
  ├─────────────────────┼──────────┼──────────┤
  │ 优化表面色彩系统    │ Color.kt │ 全局     │
  └─────────────────────┴──────────┴──────────┘
  Phase 2: 核心组件 (高优先级)
  ┌──────────────┬────────────────────┬─────────────┐
  │     任务     │      涉及组件      │  视觉提升   │
  ├──────────────┼────────────────────┼─────────────┤
  │ 增强卡片组件 │ EnhancedCard       │ 层次感 +40% │
  ├──────────────┼────────────────────┼─────────────┤
  │ 底部栏重设计 │ FloatingBottomBar  │ 精致度 +50% │
  ├──────────────┼────────────────────┼─────────────┤
  │ 滑动卡片光效 │ SwipeablePhotoCard │ 动感 +60%   │
  └──────────────┴────────────────────┴─────────────┘
  Phase 3: 页面级优化 (中优先级)
  ┌──────────┬──────────────────────────────┐
  │   页面   │            优化项            │
  ├──────────┼──────────────────────────────┤
  │ 首页     │ 数字放大、间距调整、卡片阴影 │
  ├──────────┼──────────────────────────────┤
  │ 全屏预览 │ 指示器优化、预览条放大效果   │
  ├──────────┼──────────────────────────────┤
  │ 列表页面 │ 入场动画、空状态动效         │
  └──────────┴──────────────────────────────┘
  Phase 4: 细节打磨 (持续迭代)
  ┌────────────┬──────────────────────┐
  │    细节    │         说明         │
  ├────────────┼──────────────────────┤
  │ 微交互反馈 │ 按钮按压、列表项选中 │
  ├────────────┼──────────────────────┤
  │ 过渡动画   │ 页面切换、共享元素   │
  ├────────────┼──────────────────────┤
  │ 状态徽章   │ 渐变效果、光泽层     │
  └────────────┴──────────────────────┘
  ---
  七、设计规范文档建议

  建议创建 docs/DESIGN_SYSTEM.md 作为团队设计规范参考，包含:

  1. 色彩系统 - 语义化命名、使用场景
  2. 间距系统 - Token定义、使用规则
  3. 圆角系统 - 层级对应关系
  4. 动效规范 - 时长、缓动曲线、使用场景
  5. 组件库 - 基础组件、复合组件的标准实现
  6. 图标规范 - 尺寸、颜色、使用场景

  ---
  此优化方案旨在将PhotoZen的视觉体验从"功能完备"提升至"精致灵动"，通过系统化的Token管理和统一的动效规范，确保整体体验的
  一致性和品质感。